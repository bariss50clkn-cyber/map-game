<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Global Fetih SavaÅŸÄ±</title>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #282c34; overflow: hidden; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #svg-holder { width: 100vw; height: 100vh; background: #c8c8c8; } /* Harita arka planÄ± gri tonu */
        svg { width: 100%; height: 100%; }
        path { fill: #d8d8d8; stroke: #b8b8b8; stroke-width: 0.5; transition: fill 0.6s cubic-bezier(0.4, 0, 0.2, 1), stroke 0.6s ease; }
        /* AynÄ± kullanÄ±cÄ±ya ait sÄ±nÄ±rlar daha ince veya ÅŸeffaf */
        path[data-owner][data-owner-next] { stroke-width: 0.1; stroke-opacity: 0.5; } 
        path[data-owner][data-owner-adjacent="true"] { stroke-width: 0.1; stroke-opacity: 0.5; }

        .ui-panel { position: absolute; top: 15px; left: 15px; background: rgba(15, 20, 30, 0.9); padding: 15px; border-radius: 12px; z-index: 1000; border: 1px solid #333; box-shadow: 0 4px 15px rgba(0,0,0,0.5); min-width: 250px; }
        #status { color: #4ade80; font-weight: bold; margin-bottom: 5px; display: flex; align-items: center; }
        #status::before { content: ''; display: inline-block; width: 10px; height: 10px; background: #4ade80; border-radius: 50%; margin-right: 8px; animation: blink 1.5s infinite; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .log-entry { font-size: 13px; color: #ffd700; margin-top: 8px; border-top: 1px solid #333; padding-top: 8px; max-height: 120px; overflow-y: auto; }
        .log-entry::-webkit-scrollbar { width: 5px; }
        .log-entry::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }
        .log-entry span { display: block; margin-bottom: 3px; }

        #alert-msg { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); font-size: 32px; font-weight: bold; color: #fff; text-shadow: 0 0 10px rgba(0,0,0,1); pointer-events: none; z-index: 2000; text-align: center; display: none; }

        /* KullanÄ±cÄ± Ä°sim Etiketi */
        .user-label {
            font-size: 10px;
            font-weight: bold;
            fill: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>

<div id="alert-msg"></div>
<div class="ui-panel">
    <div id="status">SAVAÅž KODU AKTÄ°F</div>
    <div id="stats" style="font-size: 12px; color: #aaa;">Toplam Fetih: 0</div>
    <div id="log" class="log-entry"><span>Hediye bekleniyor...</span></div>
    <button onclick="testAttack()" style="margin-top:10px; background:#222; color:#fff; border:1px solid #444; padding:5px 10px; border-radius:5px; cursor:pointer; font-size:10px;">El Ä°le 500 Jeton Testi</button>
</div>

<div id="svg-holder"></div>

<script>
    let provinces = [];
    const userColors = {}; // KullanÄ±cÄ±ya Ã¶zel renkleri tutar
    const conqueredProvinces = new Map(); // Hangi bÃ¶lgenin kime ait olduÄŸunu tutar
    let totalConqueredCount = 0;
    const logDiv = document.getElementById('log');

    // HaritayÄ± YÃ¼kle ve BaÅŸlat
    fetch('map.svg')
        .then(res => res.text())
        .then(data => {
            const holder = document.getElementById('svg-holder');
            holder.innerHTML = data;
            const svg = holder.querySelector('svg');
            
            if (svg) {
                svgPanZoom(svg, { zoomEnabled: true, controlIconsEnabled: false, fit: true, center: true });
                provinces = Array.from(svg.querySelectorAll('path, polygon, circle, rect'));
                provinces.forEach(p => p.id = p.id || `p${Math.random().toString(36).substr(2, 9)}`); // Her path'e ID ver
                console.log("Bulunan parÃ§a sayÄ±sÄ±:", provinces.length);
            } else {
                document.getElementById('status').innerText = "SVG BulunamadÄ±! ðŸ”´";
            }
        })
        .catch(err => {
            document.getElementById('status').innerText = "YÃ¼kleme HatasÄ±! ðŸ”´";
            console.error(err);
        });

    // KullanÄ±cÄ±ya Ã¶zel renk Ã¼retir veya var olanÄ± dÃ¶ner
    function getUserColor(user) {
        if (!userColors[user]) {
            userColors[user] = `hsl(${Math.random() * 360}, 85%, 60%)`;
        }
        return userColors[user];
    }

    // Fetih Ä°ÅŸlemi
    const executeAttack = (user, amount) => {
        if (!provinces.length) return;
        
        const userColor = getUserColor(user);
        let attackPower = Math.max(1, Math.floor(amount / 10)); // 10 jeton = 1 bÃ¶lge
        if (amount >= 500) attackPower = 75; // 500+ jetonda bÃ¼yÃ¼k saldÄ±rÄ±

        // GÃ¶rsel uyarÄ±
        const alertMsg = document.getElementById('alert-msg');
        alertMsg.innerHTML = `<span style="color:${userColor}">${user}</span> <br> ${amount} Jetonla SALDIRDI!`;
        alertMsg.style.display = 'block';
        setTimeout(() => { alertMsg.style.display = 'none'; }, 2500);

        // Fetih logunu gÃ¼ncelle
        const newLogEntry = document.createElement('span');
        newLogEntry.innerHTML = `<span style="color:${userColor}">${user}</span> +${attackPower} BÃ¶lge (${amount} Jtn)`;
        logDiv.prepend(newLogEntry); // En Ã¼ste ekle
        if (logDiv.children.length > 5) logDiv.lastChild.remove(); // Sadece son 5 logu tut

        let newlyConquered = 0;
        for (let i = 0; i < attackPower; i++) {
            let targetProvince = null;
            
            // Ã–nce kendi bÃ¶lgelerinin yanÄ±ndaki sahipsiz bÃ¶lgeleri ara
            const userOwnedProvinces = Array.from(conqueredProvinces.keys()).filter(id => conqueredProvinces.get(id) === user);
            if (userOwnedProvinces.length > 0) {
                const adjacentUnclaimed = provinces.filter(p => 
                    !p.getAttribute('data-owner') && 
                    isAdjacentToUser(p, userOwnedProvinces) // Kendi bÃ¶lgene komÅŸu mu?
                );
                if (adjacentUnclaimed.length > 0) {
                    targetProvince = adjacentUnclaimed[Math.floor(Math.random() * adjacentUnclaimed.length)];
                }
            }

            // EÄŸer komÅŸu sahipsiz bulamazsa, rastgele sahipsiz bir bÃ¶lge
            if (!targetProvince) {
                const unclaimed = provinces.filter(p => !p.getAttribute('data-owner'));
                if (unclaimed.length > 0) {
                    targetProvince = unclaimed[Math.floor(Math.random() * unclaimed.length)];
                }
            }
            
            // Hala hedef yoksa, rastgele bir bÃ¶lgeyi al (Ã¶nceki sahibini siler)
            if (!targetProvince) {
                targetProvince = provinces[Math.floor(Math.random() * provinces.length)];
            }

            if (targetProvince) {
                targetProvince.style.fill = userColor;
                targetProvince.setAttribute('data-owner', user);
                conqueredProvinces.set(targetProvince.id, user); // Kime ait olduÄŸunu kaydet
                newlyConquered++;
            }
        }
        totalConqueredCount += newlyConquered;
        document.getElementById('stats').innerText = `Toplam Fetih: ${totalConqueredCount}`;
        
        // SÄ±nÄ±rlarÄ± ve isim etiketlerini gÃ¼ncelle
        updateMapVisuals();
    };

    // Harita gÃ¶rsellerini gÃ¼ncelleyen fonksiyon (sÄ±nÄ±rlar ve isimler)
    function updateMapVisuals() {
        // TÃ¼m path'lerin data-owner-adjacent Ã¶zelliÄŸini temizle
        provinces.forEach(p => p.removeAttribute('data-owner-adjacent'));

        provinces.forEach(p => {
            const owner = conqueredProvinces.get(p.id);
            if (owner) {
                // KomÅŸu sÄ±nÄ±rlarÄ± kontrol et ve incelt
                const adjacentProvinces = getAdjacentProvinces(p); // Bu fonksiyonu SVG yapÄ±sÄ±na gÃ¶re optimize etmek gerekebilir
                for (const adjP of adjacentProvinces) {
                    if (conqueredProvinces.get(adjP.id) === owner) {
                        p.setAttribute('data-owner-adjacent', 'true');
                        adjP.setAttribute('data-owner-adjacent', 'true'); // KarÅŸÄ±daki komÅŸuyu da iÅŸaretle
                    }
                }
            }
        });

        // Eski isim etiketlerini kaldÄ±r
        document.querySelectorAll('.user-label').forEach(label => label.remove());

        // Yeni isim etiketlerini ekle (her kullanÄ±cÄ± iÃ§in bir veya iki rastgele bÃ¶lgeye)
        const usersOnMap = Array.from(new Set(conqueredProvinces.values()));
        usersOnMap.forEach(user => {
            const userOwned = provinces.filter(p => conqueredProvinces.get(p.id) === user);
            if (userOwned.length > 0) {
                // En az bir bÃ¶lgeye isim etiketi ekle
                const labelTarget = userOwned[Math.floor(Math.random() * userOwned.length)];
                addUserNameLabel(labelTarget, user);

                // EÄŸer Ã§ok fazla bÃ¶lgesi varsa, ikinci bir etiketi daha ekleyebiliriz
                if (userOwned.length > 20 && Math.random() < 0.5) { // %50 ihtimalle ikinci etiket
                    const labelTarget2 = userOwned[Math.floor(Math.random() * userOwned.length)];
                    if (labelTarget2 !== labelTarget) addUserNameLabel(labelTarget2, user);
                }
            }
        });
    }

    // KullanÄ±cÄ± adÄ± etiketi ekler
    function addUserNameLabel(provinceElement, userName) {
        const bbox = provinceElement.getBBox();
        const svg = provinceElement.ownerSVGElement;
        
        if (!svg) return;

        const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textElement.setAttribute("x", bbox.x + bbox.width / 2);
        textElement.setAttribute("y", bbox.y + bbox.height / 2 + 3); // YazÄ±nÄ±n dikey ortalamasÄ± iÃ§in 3 ekledik
        textElement.setAttribute("text-anchor", "middle");
        textElement.setAttribute("class", "user-label");
        textElement.textContent = userName;
        svg.appendChild(textElement);
    }

    // Bir bÃ¶lgenin belirli bir kullanÄ±cÄ±nÄ±n bÃ¶lgelerine komÅŸu olup olmadÄ±ÄŸÄ±nÄ± kontrol eder
    // NOT: Bu fonksiyon, kullandÄ±ÄŸÄ±nÄ±z SVG haritasÄ±nÄ±n iÃ§ yapÄ±sÄ±na gÃ¶re hassas ayar gerektirebilir.
    // Åžimdilik basit bir kontrol yapÄ±yor. GerÃ§ek komÅŸuluk iÃ§in "id" ve komÅŸuluk listesi gerekebilir.
    function isAdjacentToUser(province, userOwnedProvinceIds) {
        // Basit bir yaklaÅŸÄ±m: EÄŸer bÃ¶lgenin ID'si, kullanÄ±cÄ±nÄ±n bÃ¶lgelerine komÅŸu olabilecek
        // bir Ã¶rÃ¼ntÃ¼ye sahipse (Ã¶rn: "TR-01" ve "TR-02") veya BBox'larÄ± Ã§akÄ±ÅŸÄ±yorsa.
        // Daha doÄŸru bir komÅŸuluk tespiti iÃ§in SVG haritasÄ±nÄ±n topolojisine bakmak gerekir.
        // Bu, genelde her path'in komÅŸularÄ±nÄ± bir "adjacency list" iÃ§inde tutularak yapÄ±lÄ±r.
        
        // Åžimdilik, sadece rastgele bir bÃ¶lgenin yanÄ±nda olma ihtimalini artÄ±rÄ±yoruz.
        // GerÃ§ek komÅŸuluk iÃ§in SVG path'lerinin kesiÅŸimlerini kontrol etmek Ã§ok karmaÅŸÄ±k.
        // EÄŸer bu kÄ±sÄ±m yetersiz gelirse, SVG haritasÄ±na Ã¶zel bir komÅŸuluk listesi eklememiz gerekir.
        
        // Alternatif olarak, eÄŸer SVG'nizdeki path'lerin id'leri mantÄ±ksal olarak birbirine baÄŸlÄ±ysa
        // (Ã¶rn: "prov_1", "prov_2"), burada kontrol edilebilir.
        
        // Åžimdilik, bir bÃ¶lgenin ID'si varsa ve komÅŸuluk listesi varsa kullan.
        // Yoksa, sadece rastgeleliÄŸi artÄ±r.
        return Math.random() < 0.3; // %30 ihtimalle komÅŸu say
    }

    // Bir bÃ¶lgenin komÅŸu bÃ¶lgelerini bulur (genel amaÃ§lÄ±, SVG yapÄ±sÄ±na gÃ¶re optimize edilmeli)
    function getAdjacentProvinces(province) {
        const adjacent = [];
        // Bu kÄ±sÄ±m, haritanÄ±n SVG yapÄ±sÄ±na baÄŸlÄ±dÄ±r. EÄŸer her path'in bir ID'si varsa
        // ve bir komÅŸuluk listesi (adjacency list) oluÅŸturulabilirse daha doÄŸru olur.
        // Åžimdilik, sadece yakÄ±nÄ±ndaki rastgele birkaÃ§ bÃ¶lgeyi komÅŸu sayÄ±yoruz.
        
        // GerÃ§ek komÅŸuluk tespiti iÃ§in, her bir path'in bounding box'Ä±nÄ± kontrol edip
        // birbirine yakÄ±n olanlarÄ± veya kesiÅŸenleri bulmak gerekir. Bu oldukÃ§a yoÄŸun bir iÅŸlem.
        
        // Basitlik adÄ±na, ÅŸimdilik rastgele komÅŸular dÃ¶nÃ¼yoruz.
        // Daha geliÅŸmiÅŸ bir komÅŸuluk iÃ§in, SVG haritanÄ±zÄ±n nasÄ±l oluÅŸturulduÄŸu Ã¶nemlidir.
        for(let i=0; i<3; i++) { // Her prov iÃ§in 3 rastgele komÅŸu
            adjacent.push(provinces[Math.floor(Math.random() * provinces.length)]);
        }
        return adjacent;
    }


    // TikFinity Sinyal Takibi (URL parametreleri ile)
    setInterval(() => {
        const params = new URLSearchParams(window.location.search);
        if (params.has('user')) {
            const u = params.get('user');
            const a = parseInt(params.get('amount')) || 1;
            executeAttack(u, a);
            window.history.replaceState({}, document.title, "/"); // URL'yi temizle
        }
    }, 500); // Her 0.5 saniyede bir URL'yi kontrol et

    // Test Butonu Fonksiyonu
    function testAttack() {
        executeAttack("GlobalKing", 500); // Test iÃ§in 500 jetonluk saldÄ±rÄ±
    }
</script>
</body>
</html>
